### Тестирование функции в консоли:

1. "Загрузка" функции и запуск консоли

```python -i _1_divisor.py```
В открывшейся консоли интерпретатор уже будет знать про нашу функцию ```divide()```

2. Запуск функии divide() c нужными параметрами
```
>>> divide(10, 5)  
2
>>> divide(2, 2)  
1
```
### Тестирование doctest:
В ```doctest``` используется "консольный" синтаксис.
Для тестирования мы можем скопировать 4 строки выше и вставить в ```Docstring``` нашей функции ```divide()```

```Doctest``` полезен тем, что в самой документации мы указываем примеры использования нашей функции.
Сами тесты пишутся как правило самые простые и не покрывают всех случаев.
Для максимально полного тестирования все-таки лучше использовать ```unittests```

### Тестирование unittest:
Покрытие случая, когда мы можем получить деление на ноль мы реализовали в модуле ```divisor_test.py```

Как видим, неудобно что часть тестов у нас реализованы в doctest, а часть в unittest. Хотелось бы их объединить.

### Интеграция doctest в unittest:
В файл с нашим юниттестом необходимо добавить функцию ```load_tests()```,
которая на основании doctest автоматически сформирует еще один unittest и добавит его 
к тем, что уже прописаны в данном файле.

Таким образом, doctest также пойдут на пользу дела тестирования,
а прогонять все тесты по-прежнему можно будет нажатием одной кнопки.

```
def load_tests(loader, tests, ignore):
    tests.addTests(doctest.DocTestSuite(your_module_name))
    return tests
```

### Настройка конфигураций тестирования

![img](/images/img3.png)

1. В Pycharm в правом верхнем углу, слева от кнопки ```Run``` во всплывающем меню выбрать ```Edit Configurations...```
2. В левом верхнем углу окна выбрать ```Add new configuration```
3. Выбрать ```Unittest```
4. Указать имя создаваемой конфигурации ```Name: MyUnitTests```
5. Указать ```Target: Custom```
6. Указать ```Additional Arguments:```

Additional Arguments:

```
discover -s PATH -p '*test.py'
, где PATH-абсолютный! путь к папке с тестами
Пример:
(discover -s doctest_unittest -p '*test.py')
```

Данные настройки позволяют выполнять все тесты, находящиеся в указанной папке нажатием одной кнопки, что очень удобно.

### Для самостоятельного изучения:
- Функция patch() в библиотеке unittest.mock

Данная функция позволяет заменять реальные объекты в коде на экземпляры Mock. Её можно использовать как декоратор или контекстный менеджер, что даёт контроль над областью, в которой будет имитироваться объект.